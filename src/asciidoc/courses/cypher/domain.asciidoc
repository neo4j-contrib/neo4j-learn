[[tutorials-cypher-domain]]

== Cypher Tutorial ==

Cypher is intended to be a easy to write, easy to write language, which is still expressive
and powerful.


=== Setup ===
To run this tutorial, you have two options. Either download and run the Neo4j Server or use our online Cypher console with a prepared dataset.

////
create statement for the console
////

==== Neo4j Server ====
* download the http://neo4j.org/download[Neo4j Community server for your platform] 
* download and unzip the http://example-data.neo4j.org[sample cineasts dataset] in +data/graph.db+
* start the server with +bin/neo4j start+

==== Neo4j Console ====

The Neo4j Console is an online interactive shell that can be used to create graphs, experiment with them and share your data (like a gist) with a single click.

We prepared a http://console.neo4j.org[console] with a fraction of the domain dataset to be used.

=== Quick intro to the graph model we use

The domain we use is a social movie database, it consists of movies, actors, directors and users. 

* An actor acts in a movie in a certain role: `(actor)-[role:ACTS_IN]->(movie)`
* A director directed a movie: `(director)-[DIRECTED]->(movie)`
* A user rated a movie: `(user)-[:RATED]->(movie)`
* A user is fried of another user `(user)-[:FRIEND]->(other_user)`


////
* Use cypher in different languages (gists)
* References (cheat-sheet, manual, screencast)
////

include::docs/neo4j-examples-docs-jar/dev/hello-world.txt[]


.Notes
****
* While working, refer to the http://neo4j.org/resources/cypher[cypher cheat sheet]
* http://neo4j.org/download[Get Neo4j Server] 
* Add the demo graph http://example-data.neo4j.org[cineasts]
* tell them to stop the screencast and get it done
* Show webadmin 
* Show the console
****

////
I want to make this part of the documentation, generated by tests
then I want to make this into a slide deck (with deck.js) which is used in the screencast

Setup a neo4j console link and also a heroku instance with the dataset
Can we add a "deploy to heroku" link for the example datasets? or a show in Neo4j console
////

== Cypher Screencast Series

////
5 Installations each 5-8 minutes

# Quickstart (can we reuse Alistairs screencast?)

* Refer to the cypher cheat sheet
* Get Neo4j Server http://neo4j.org/download
* Add the demo graph (cineasts) http://example-data.neo4j.org 
* tell them to stop the screencast and get it done
* Show webadmin 
* Show the console
////

=== Quickstart

* return a single node, by id  (The Matrix) 
[source, cypher]
start m=node(89) return m;

* return the title and id of the matrix node `start m=node(89) return m.id, m.title;`
* find a node in the index `start m=node:Movie(id="603") return m;` or `start m=node:search("title:matrix") return m;`
* first use of the match clause, show all actors
  `start m=node:Movie(id="603") match m<-[:ACTS_IN]-actor return actor;`
* return just the name, order them by name
  `start m=node:Movie(id="603") 
   match m<-[:ACTS_IN]-actor 
   return actor.name 
order by actor.name;`
* first aggregation, count the actors
  `start m=node:Movie(id="603") 
   match m<-[:ACTS_IN]-actor 
   return count(*);`
* first filtering only the actors born in the US 
  `start m=node:Movie(id="603") 
   match m<-[:ACTS_IN]-actor 
   where actor.birthplace =~ /.*(United States|US).*/ 
   return actor.name ;`

* some exploratory queries for unknown datasets, don't do that on live production instances
  `start n=node(*) return count(*);`
  `start n=node(*) match n-[r?]->() return type(r), count(*);` or for a single node

=== Updating the graph

* same setup as before
* we will add ourselves, friends and ratings
* add a node for yourself and return it, note the id `create me={name: "Michael"} return me;`
* let's check if the node is there: `start me=node(488) return me.name;`
* I want to rate a movie `start me=node(488), movie=node:Movie(id="603") create me-[:RATED {stars : 5, comment : "I love that movie!"}]->movie;`
* which movies did I rate `start me=node(488) match me-[r:RATED]->movie return r.stars, r.comment,movie.title;`
* we need a friend `create friend={name: "A Friend"} return friend;` // node(489)
* add our friendship idempotently, so we can rerun the query without adding it several times, we return the relationship to check that it has not been created several times
`start me=node(488), friend=node(489) relate me-[r:FRIEND]->friend return r;`
* rerun the query
* update our friendship with a `since` property
`start me=node(488), friend=node(489) MATCH me-[r:FRIEND]->friend set r.since='forever' return r;`
* we pretend being our friend and want to see which movies our frriends have rated
`start me=node(489) MATCH me-[:FRIEND]-friend-[r:RATED]->movie return movie.title, avg(r.stars), collect(r.comment), count(*);`
* that's too little data, let's add some more friends and ratings
start me=node(488)
foreach (i in range(1,10) : create me-[:FRIEND]->({name:"Friend "+i}))

=== Paths everywhere
* same setup as before, with all the added friends and ratings
* lets explore the relationships between the actors
* All other movies that the matrix actors acted in ordered by occurrence
`start m=node:Movie(id="603") match m<-[:ACTS_IN]-actor-[:ACTS_IN]->movie return movie.title, count(*) order by count(*) desc;`

* obviously the Matrix trilogy, but also others, let's see which actors
`start m=node:Movie(id="603") match m<-[:ACTS_IN]-actor-[:ACTS_IN]->movie return movie.title, collect(actor.name) order by count(*) desc;`
* what about co-acting, actors that acted together
`start m=node:Movie(id="603") match m<-[:ACTS_IN]-actor-[:ACTS_IN]->movie<-[:ACTS_IN]-colleague return actor.name, collect(distinct colleague.name);`
* who of those other actors acted most often with anyone from the matrix cast
`start m=node:Movie(id="603") match m<-[:ACTS_IN]-actor-[:ACTS_IN]->movie<-[:ACTS_IN]-colleague return colleague.name,count(*) order by count(*) desc limit 10;`
* starting with paths, a path is a sequence of nodes and relationships from a start node to an end nod
* we know that Trinity loves Neo, but how many paths exist between their actors; we limit the path length and the query as it exhaustively searches the graph otherwise
`start neo=node:Person(id="6384"),trinity=node:Person(id="530") match p = neo-[:ACTS_IN*0..5]-trinity return p, length(p) limit 10;`
* that's a lot of data, we just want to look at the names and titles of the nods of this path
`start neo=node:Person(id="6384"),trinity=node:Person(id="530") match p = neo-[:ACTS_IN*0..5]-trinity return extract(n in nodes(p) : coalesce(n.title?,n.name?)), length(p) order by length(p) limit 10 ;`
* let's explore connections between more people, we chose an actor who has only a few connections to the team, Sean Bean (Boromir, Eddard Stark) is a good candiate (id 467)
`start m=node:Movie(id="603"),sean=node(467) match m<-[:ACTS_IN]-actor,p  return colleague.name,count(*) order by count(*) desc limit 10;

////
Integration:
Use the Neo4j Console for exploration, sharing and testing
Deploy an instance of the graph to heroku, create the ruby forwarding app, and upload the dataset
Use the JDBC driver for integration with existing tools
////

The interactive explorative console will help you throughout this course:

++++
<iframe width="560" height="315" src="http://console.neo4j.org" frameborder="0" allowfullscreen></iframe>
++++

=== Screencast Video: Intro to Cypher ===

++++
<iframe title="Neo4j Videography Video Player" width="640" height="360" src="http://video.neo4j.org/player/ybMbf" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe>
++++
